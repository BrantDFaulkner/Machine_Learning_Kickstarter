---
title: "Exploratory_Analysis"
output: html_document
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Exploratory Analysis

```{r include = FALSE}
#Customize ggplot theme
theme_set(theme_minimal())
theme_update(axis.text.x = element_text(angle = 60, hjust = 1))
theme_update(plot.title = element_text(color="#666666", face="bold", size=22, hjust=0))
theme_update(axis.title = element_text(color="#666666", face="bold", size=18))
theme_update(plot.title = element_text(hjust = 0.5))
```


## Ex Post Facto
Ex Post Facto variables are those that generally only exist at the end of the project. These are interesting to examine and can provide valuable insight into Kickstarter, however, they are not appropriate to use in our predictive models as they are pseudo outcome variables. 

### `backers_count`
`backers_count` is a powerful predictor of project funding. We can see that the distribution resembles a logistic function. We found it surprising that even at the top 5% of `backers_count` there are still projects that are not funded. We hypothesize that these projects have an extremely large `goal`.

```{r echo = FALSE}
df_backers = data.frame(funded = df_engr$funded, backers_count = df_engr$backers_count)
df_backers$df_bc_20 = cut(df_backers$backers_count, breaks = unique(quantile(df_backers$backers_count, seq(0, 1, by = .05))), include.lowest = TRUE)

df_backers %>% 
  group_by(df_bc_20) %>%
  summarise(avg_funded = mean(funded)) %>%
  ggplot(aes(x = df_bc_20, y = avg_funded)) +
    geom_bar(stat="identity", fill = "#332288") +
    labs(title = "Funding By Backers",
         x="Number of Backers",
         y="Chance of Funding")
  
#Clean Up
rm(df_backers)
```

## Day Zero
Day Zero variables are any which can be observed and/or controlled at the start of the project. These are the most important for our predictive models as they allow us to predict a project's funding before any Kickstarter activity. 


### `category`

Some categories never fail in this dataset (only considered if n > 50):
* design/product design (1098 projects)
* film & video/documentary (2202 projects)
* film & video/shorts (3513 projects)
* games/tabletop games (1064 projects)

Most successful parent categories (only considered if n > 100):
* 7 1,725 projects 81.2% successful
* 11 12,087 projects 65.2% successful
* 14 14,635 projects 59.2% successful

Least successful parent categories (only considered if n > 100):
* 18 8,725 projects 39.7% successful
* 16 1,638 projects 46.2% successful
* 12 4,125 projects 46.9% successful
  
```{r echo = FALSE}
# By main category
# 15 unique categories


df_engr %>%
  group_by(category) %>%
  summarise(count = n(), 
            success_rate = round(mean(funded)*100, 2), 
            avg_goal = mean(goal, na.rm = TRUE), 
            #min(percent_funded, na.rm = TRUE), 
            med_perc_funded = median(percent_funded, na.rm = TRUE), 
            #max(percent_funded, na.rm = TRUE),
            avg_perc_funded = mean(percent_funded, na.rm = TRUE), 
            avg_backer_count = mean(backers_count), 
            #min(backers_count), 
            med_backer_count = median(backers_count), 
            #max(backers_count), 
            avg_contribution = mean(avg_contribution, na.rm = TRUE), 
            #min(avg_contribution, na.rm = TRUE), 
            med_contribution = median(avg_contribution, na.rm = TRUE)) %>%
            #max(avg_contribution, na.rm = TRUE)) %>%
  arrange(desc(count)) %>%
  ungroup(category)

#Logit
#Some categories significant
#logit_category <- glm(funded ~ category, data = df_engr, family = binomial(link='logit'))
#summary(logit_category)
#Clean up
#rm(logit_category)
```

#### Frequency by `category`
The distribution of projects by category shows Kickstarter has an intense focus on creative projects. We hypothesize that the minimal appearance of some categories suggests that Kickstarter's classification system tends to favor large, general grouping. It may also be arbitrary in some instances as many `dance` and `photography` projects could readily be placed in `art`.

```{r echo = FALSE}
df_engr %>% 
  group_by(category) %>%
  summarise(count = n()) %>%
  ggplot(aes(x = reorder(category, -count), y = count)) +
  geom_bar(stat="identity", fill = "#332288") +
  labs(
    title = "Frequency By Category",
    x="Project Category", 
    y="Number of Projects")

```

```{r echo = FALSE}
df_engr %>% 
  group_by(category) %>%
  summarise(count = n(), 
            funded_rate = round(mean(funded)*100, 2)) %>%
  arrange(desc(count)) %>%
  ggplot(aes(x = reorder(category, -count), y = funded_rate)) +
  geom_bar(stat="identity", fill = "#332288") +
  labs(
    title = "Funding By Category",
    x="Project Category", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))

```

## Explore $comments_count
The vast majority of projects received fewer than 20 comments. Success rate seems to increases exponentially when more comments are received.

```{r}
df_commments = data.frame(funded = df_engr$funded, 
                          comments_count = db_cleaned$comments_count)
df_commments$df_cc_20 = cut(df_commments$comments_count, 
                            breaks = unique(quantile(df_commments$comments_count, 
                                                     seq(0, 1, by = .05))), 
                            include.lowest = TRUE)

df_commments %>% 
  ggplot(aes(x = df_cc_20, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Comments",
    x="Number of Comments", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))

#Logit
#significant
logit_comments <- glm(funded ~ comments_count, data = df_commments, family = binomial(link='logit'))
summary(logit_comments)

#Group into deciles and look as levels
#df_comments_count_filtered <- db_cleaned %>%
#  filter(comments_count <= 200) %>% 
#  mutate(comment_count_10 = cut(comments_count, 10))

#df_comments_count_filtered %>%
#  ggplot() + 
#  theme_minimal() + 
#  ggtitle("$comment_count in Deciles") + 
#  geom_histogram(aes(comment_count_10), stat = "count")

#df_comments_count_filtered %>%
#  group_by(comment_count_10) %>%
#  summarise(n(), 
#            mean(comments_count), 
#            success_rate = round(mean(funded)*100, 2), 
#            mean(backers_count), 
#            mean(avg_contribution, na.rm = TRUE)) %>%
#  ungroup(comment_count_10)

#Clean up
rm(logit_comments)
rm(df_commments)
```


##$goal
Goal is likely a good predicter. The vast majority of goals are under $50,000. The likelihood of being funded decreases as goals get larger.

```{r}
df_engr %>% 
  ggplot(aes(x = goal_20, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Goal",
    x="Goal Amount", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))

#Linear Models
summary(glm(funded ~ goal, data = df_engr))
summary(glm(funded ~ goal_20, data = df_engr))
```

##$launched_at
The number of projects increased exponentially 2009 - 2012 and seems to be increasing more gradually after 2012.
The dataset has only partial data for December 2013.

```{r}
df_engr %>%
  group_by(mo_yr_launched)  %>% 
  summarise(n(), 
            success_rate = round(mean(funded)*100, 2),
            mean(percent_funded, na.rm = TRUE), 
            mean (avg_contribution, na.rm = TRUE)) %>%
  ungroup(mo_yr_launched)

df_engr %>% 
  ggplot(aes(x = yr_launched, y = funded)) +
  geom_bar(stat="identity", fill = "#332288") +
    labs(
    title = "Project Launch By Year",
    x="Year", 
    y="Projects Launched") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))

df_engr %>% 
  ggplot(aes(x = yr_launched, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Year",
    x="Year", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))

df_engr %>% 
  ggplot(aes(x = mo_launched, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Goal",
    x="Goal Amount", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))

summary(glm(funded ~ mo_launched, data = df_engr))

```

##location variables
###$country
The majority of projects are based in the United States. Domestic projects have a success rate about 7% higher than international projects.  

```{r}
df_country <- data.frame(funded = df_engr$funded, country = db_cleaned$country, usa = df_engr$usa)

df_country %>%
  group_by(country) %>%
    summarise(count = n(), funded_rate = mean(funded)) %>%
  arrange(desc(count)) %>%
  ungroup(country)

summary(lm(funded ~ usa, data = df_country))

#Clean up
rm(df_country)
```


##$photo_key
There are not enough zero values for prediction, and a t-test shows no significant difference between having and not having a photo. This is probably not because photos don't matter, but rather because the sample with no photo is too small to have statistical power.

```{r}
df_engr %>%
  group_by(photo_key) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(photo_key)

t.test(funded ~ photo_key, data = df_engr)
```

##$pledged
The higher the pledged amount, the more backers there are. The average contribution per backer does not seem to change much even as the amount pledged increases.

```{r}
# # Group into deciles and look as levels
# df_filtered_by_pledged <- db_cleaned %>%
#   filter(pledged < 200000) %>%
#   mutate(pledged_10 = cut(pledged, 10))
# 
# #df_filtered_by_pledged %>%
#   group_by(pledged_10) %>%
#   summarise(n(), 
#             mean(pledged), 
#             mean(backers_count), 
#             mean(avg_contribution, na.rm = TRUE)) %>%
#   ungroup(pledged_10)
# 
# df_filtered_by_pledged %>%
#   ggplot() + 
#   theme_minimal() + 
#   ggtitle("$pledged in Deciles") + 
#   geom_histogram(aes(pledged_10), stat = "count")
# 
# #Clean up
# rm(df_filtered_by_pledged)
```

##$spotlight
Spotlight is an ex post facto variable that features funded projects.
[Kickstarter Spotlight](https://www.kickstarter.com/spotlight)

```{r}
df_engr %>%
  group_by(spotlight) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(spotlight)
```

##$staff_pick
This flag denotes projectsthat have received the "Projects We Love" badge and get prominantly features on the website, newsletters, and blogs. Kickstarter staff clearly has a great eye for promossing projects and/or some strong marketing impact.
[Kickstarter - Projects We Love](https://www.kickstarter.com/discover/recommended)

```{r}
df_engr %>%
  group_by(staff_pick) %>%
    summarise(n(), mean(funded)) %>% 
  ungroup(staff_pick)
```

##$funded
On average: projects that are funded far exceed their goal amount; the average contribution per backer is higher and there are more backers; and the goal amount tends to be significantly lower.

```{r}
df_engr %>%
  group_by(funded) %>%
  summarise(n(),
            mean(percent_funded, na.rm = TRUE), 
            mean(avg_contribution, na.rm = TRUE), 
            mean(goal, na.rm = TRUE),
            mean(backers_count), 
            median(backers_count), 
            max(backers_count), 
            mean(avg_contribution, na.rm = TRUE)) %>%
  ungroup(funded)
```

##$video_status
T test shows having a video to statistically significantly impact the success of the project. 

```{r}
df_engr %>%
  group_by(video_status) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(video_status)

t.test(funded ~ video_status, data = df_engr)
```

##Social media connectedness variables
Social media shows an impact. Facebook seems to be the strongest and Youtube has a negative coefecient. Our hypothesis is that Facebook and Twitter may be used for promotion, while creators focusing on YouTube may over rely on their product content. Yet the most successfull creators have all three, which supports that YouTube is effective when paired with a comprehensive social media campaign.

```{r}
#facebook
df_engr %>%
  group_by(facebook) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(facebook)

#twiter
df_engr %>%
  group_by(twitter) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(twitter)

#youtube
df_engr %>%
  group_by(youtube) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(youtube)

#social_media
df_engr %>%
  group_by(social_media) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(social_media)

lm_social_media <- lm(funded ~ social_media, data = df_engr)
summary(lm_social_media)


#social_media_count
df_engr %>%
  group_by(social_media_count) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(social_media_count)

lm_social_media_count <- lm(funded ~ social_media_count, data = df_engr)
summary(lm_social_media_count)

df_engr %>% 
  ggplot(aes(x = social_media_count, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean") +
  theme_minimal()

#Clean up
rm(lm_social_media_count, lm_social_media)
```

##$campaign_duration
Interestingly, campaign duration has an inverse relationship to the likelihood of receiving funding; longer campaign are associated with higher failure rates.

```{r}
#Linear Model
#not significant
lm_length <- glm(percent_funded ~ campaign_duration, data = df_engr)
summary(lm_length)

#Logit
#significant
logit_length <- glm(funded ~ campaign_duration, data = df_engr, family=binomial(link='logit'))
summary(logit_length)

df_engr %>%
  ggplot() +
  theme_minimal() + 
  ggtitle("$campaign_length Logistic Model") +
  geom_point(aes(x=campaign_duration, y=funded), colour = "black") +
  geom_point(aes(x=campaign_duration, y=logit_length$fitted.values), colour = "red")

rm(lm_length, logit_length)
```

##$avg_contribution
Appears to have a skewed normal distribution with a mean of $72.

```{r}
#Chck for NA
anyNA(df_engr$avg_contribution)

mean(df_engr$avg_contribution, na.rm = TRUE)

# Apparently normal distribution
df_filtered_by_avg_contribution <- df_engr %>%
  filter(avg_contribution < 1500)

# Box Plot
boxplot(df_filtered_by_avg_contribution$avg_contribution)

# Histogram
df_filtered_by_avg_contribution %>%
  ggplot() + 
  geom_histogram(aes(x = avg_contribution))

#Clean up
rm(df_filtered_by_avg_contribution)
```

##$percent_funded
Non-normal distribution shows that most projects over ~75% of their goal wind up being successful. There may be outside manipulation happening due to Kickstarter promotions of projects that are near their goals, or personal donations by the creators and/or creators personal connections.

```{r}
# Check for NA
anyNA(df_engr$percent_funded)

mean(df_engr$percent_funded, na.rm = TRUE)

df_filtered_by_percent_funded <- df_engr %>%
  filter(!is.na(percent_funded) & percent_funded <= 400)

# Box Plot
boxplot(df_filtered_by_percent_funded$percent_funded)

# Non-normal distribution
df_filtered_by_percent_funded %>% 
  ggplot() + 
  geom_histogram(aes(x = percent_funded))

#Clean up
rm(df_filtered_by_percent_funded)
```

##$description_length

```{r}
df_engr %>% 
  ggplot(aes(x = description_length_10, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Description",
    x="Length of Description", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))
```

##Profile variables
$profile_blurb, $profile_state

```{r}

```

##$rewards

```{r}
df_engr %>% 
  ggplot(aes(x = reward_length_10, y = funded)) +
  stat_summary(geom = "bar", fun.y = "mean", fill = "#332288") +
    labs(
    title = "Funding By Rewards",
    x="Length of Rewards", 
    y="Chance of Funding") + 
  theme_minimal() +
  theme_update(axis.text.x = element_text(angle = 60, hjust = 1))


```

##$updates_count
```{r}

```

## Date variables
```{r}
#Average of 2-20 minutes difference btween deadline and failed_at, successful_at, state_changed_at
#Difference is not meaningful, so remove failed_at, successful_at, state_changed_at
ticktock <- data.frame(db_cleaned$created_at, 
                       db_cleaned$deadline, 
                       db_cleaned$failed_at, 
                       db_cleaned$launched_at, 
                       db_cleaned$state_changed_at, 
                       db_cleaned$successful_at)

ticktock <- mutate(ticktock, 
                   deadline_failed = db_cleaned.deadline - db_cleaned.failed_at,
                   deadline_success = db_cleaned.deadline - db_cleaned.successful_at,
                   deadline_state = db_cleaned.deadline - db_cleaned.state_changed_at)

mean(ticktock$deadline_failed, na.rm = TRUE)
mean(ticktock$deadline_success, na.rm = TRUE)
mean(ticktock$deadline_state)

rm(ticktock)
```

## Not Fully Explored
More granular location variables would require more cleaning and may produce regional insights. 
* `location_name`
* `location_state`
* `location_type`


## Rejected
We looked at this, yet did not find them to be predictive:
* `project_id`
* `disable_communicaiton`


```{r}
##$project_id
#A random identifier, cannot easily observe a pattern
range(db_cleaned$project_id)
```

```{r include=FALSE, eval=FALSE}
##$converted_pledged_amount
#Validate hypothesis that $converted_pledged_amount = $fx_rate * $pledged

# fx_rate is the exchange rate to USD
for (i in length(db_cleaned$converted_pledged_amount)) {
  if (db_cleaned$converted_pledged_amount[i] == db_cleaned$fx_rate[i]*db_cleaned$pledged[i]) {
    i = i + 1
  } else {
    print("FALSE")
  }
  print("COMPLETE")
}
```

```{r include=FALSE, eval=FALSE}
##$disable_communication
#This is not a user initiated setting, rather an effect of a project being suspended.

df_filtered_disable_communicaiotn <- db_cleaned %>%
  filter(disable_communication == "True")

df_filtered_state_suspended <- db %>%
  filter(state == "suspended")

rownames(df_filtered_disable_communicaiotn) == rownames(df_filtered_state_suspended)

#Clean Up
rm(df_filtered_disable_communicaiotn)
rm(df_filtered_state_suspended)
```

```{r include=FALSE, eval=FALSE}
###Other Location variables
#These would require a lot of cleaning, and might be valuable for making heat maps. However, they are not condusive to making a prediction.

df_country <- data.frame(funded = df_engr$funded,
                         location_name = db_cleaned$location_name,
                         location_state = db_cleaned$location_state,
                         location_type = db_cleaned$location_type)

df_country %>%
  group_by(location_name) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(location_name)

df_country %>%
  group_by(location_state) %>%
    summarise(n(), mean(funded)) %>% 
  ungroup(location_state)

df_country %>%
  group_by(location_type) %>%
    summarise(n(), mean(funded)) %>%
  ungroup(location_type)

rm(df_country)
```
